1. 描述一下Unity资源热更的流程
	1. 将资源打包成独立格式(如AssetBundle),生成版本号校验信息之类的
	2. 将资源文件部署到游戏服务器或者CDN
	3. 客户端打开时验证资源完整性和版本,动态下载资源(UnityWebRequest)
	4. 卸载旧版本资源,加载新资源并更新依赖
2. 代码热更的流程呢(HybridCLR)
	1. 代码的编译与转换  将更新的C#代码转换为dll文件
	2. 将文件打包为独立的资源
	3. 部署到服务器
	4. 客户端请求服务器版本号,不同,下载热更资源,
	5. 通过CLR运行时动态加载 dll 中的 IL字节码.
	6. 覆盖或注入新代码到现有运行时环境
3. 介绍一下Unitask
	1. **Unitask** 是一个基于 Unity 的现代化异步任务库，旨在简化游戏开发中的异步编程，提升性能并降低代码复杂度。它提供了类似 C# `async/await` 的语法糖，同时深度集成 Unity 生态，支持协程、任务并行、取消操作、异常处理等高级特性。
4. 讲一下UniTask和DoTween构建的UI动画框架
	1. 把游戏中所有的UI panel 做成预制体
	2. 简单将每个预制体路径和名称做一个映射
	3. 每个panel预制体的脚本继承一个BasePanel 父类
	4. 有一个公共管理类UIManager负责维护已打开面板的字典和,打开,关闭面板的api
	5. 在打开关闭时可以加入DoTween,实现淡入淡出效果
	6. 使用UniTask加载所有Prefab,避免阻塞主线程
	7. [[UGUI通用框架]]
5. 如何实现弹窗队列（Popup Queue）的管理
	1. 创建先入先出队列,新建弹窗对象首先加入队列中(按顺序加载资源,避免同时发起过多请求)
	2. 创建弹窗实例(DoTween)
	3. 启动自动关闭计时器(DoTween)
	4. 使用对象池复用弹窗对象
	5. 将弹窗的 UI 元素统一到一个 Canvas 下, 动静分离
6. 资源自动化检测工具如何实现(不使用的资源)
	1. **批量检测并清理项目中未被使用的纹理资源**
	2. 页面上允许使用者选择多个搜索目录,动态验证目录的有效性
	3. 分帧搜索所有未使用资源
	4. 遍历选定目录中所有的 指定类型(Texture资源.
	5. 通过多维度检查纹理图片是否被项目引用:
		1. 直接依赖:检查资源是否被其他资产直接依赖
		2. 反向依赖:检查是否有资产反向引用该资源
		3. 预制体引用:检查是否被任何预制体使用
		4. 场景引用:检查是否在场景中加载.
		5. 代码引用:检查脚本文件中的字符串是否匹配(路径或者名称)
	6. 结果显示和操作
		1. 显示未使用为例的缩略图和路径
		2. 支持单个删除,批量删除和一键清理
	7. 性能优化
		1. 分帧处理资源(每帧检查少量资源,避免主线程阻塞)
		2. 使用缓存机制,减少重复计算
7. 数据加解密工具的实现
	1. 使用AES加密。密钥可以存在本地使用obs或者放在服务器
8. 代码混淆工具的实现
	1. 变量名,替换所有文件(遇到了替换公共api的变量,然后开始做黑名单)
	2. 类名,函数名同上。（使用正则表达式匹配）
	3. 插入垃圾函数 和垃圾变量   判断{ }层级，选择插入位置
9. 图片替换 (替换所有预制体中的图片)
	1. 创建一个Unity编辑器工具窗口
	2. 允许用户选择要替换的原始Sprite和新的Sprite
	3. 所有预制体中查找并替换指定的Sprite
	4. 提供操作反馈和错误处理
10. 编辑器模式下对Text的一键修正
	1. 由于刚接手的一个项目中UI标题格式参差不齐,各个预制体中标题的命名和位置五花八门,所以写个小工具,使在组件通过点击添加一个脚本,自动运行脚本内容,添加Text,并自动填写统一的参数.
11. 
	