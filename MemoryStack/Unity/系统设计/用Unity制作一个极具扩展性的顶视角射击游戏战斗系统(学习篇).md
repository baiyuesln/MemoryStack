
	https://zhuanlan.zhihu.com/p/416805924
	https://github.com/kierstone/Buff-In-TopDownShooter

#系统设计 

	 对上面这篇战斗系统的博客进行学习理解记录
## 战斗系统元素

![[Pasted image 20250211113849.png]]
## ECS与Unity设计模式

Unity的GameObject-Component模式与ECS确实有表面相似性，但其设计哲学和实现细节存在本质差异，具体可以从以下几个角度理解：

---

### 1. **身份认定的差异**

- **ECS的Entity**：  
    是纯粹的逻辑容器，本身**没有身份和语义**。其意义完全由拥有的Component组合决定。Entity类似空盒子，内容和意义动态变化，System通过筛选Component组合来处理相应逻辑（如"有位置+渲染数据"的实体才被渲染）。
    
- **Unity的GameObject**：  
    **隐含身份概念**。例如一个带有"EnemyController"组件的GameObject，开发者会默认将其视为敌人。组件更像是为已有概念的对象（如敌人、玩家）添加功能，而非定义其本质。
    

---

### 2. **组件责任的差异**

- **ECS的Component**：  
    **纯数据容器**，严格禁止逻辑（仅有数据字段）。例如VelocityComponent只包含速度值，System负责移动计算。组件间解耦，System组合使用多个组件实现功能。
    
- **Unity的Component (MonoBehaviour)**：  
    **数据和逻辑混合**。组件通常包含字段（数据）和方法（逻辑），例如EnemyController可能既有血量数据，又有攻击逻辑。组件间通过`GetComponent`或消息传递协作，容易形成紧耦合。
    

---

### 3. **数据访问效率的差异**

- **ECS的组合式内存布局**：  
    相同类型Component连续存储（如所有PositionComponent在内存中连续排列），System遍历时缓存命中率高，适合处理大量实体（如万级粒子效果）。
    
- **Unity的GameObject内存模型**：  
    GameObject和Component分散在堆内存中，遍历时频繁跳转内存地址，缓存效率低。适合少量复杂对象（如场景中的角色、道具），但海量实体时性能急剧下降。
    

---

### 4. **设计目标的差异**

- **ECS的核心目标**：  
    数据驱动的高性能计算，通过分离数据与逻辑、高效内存布局，充分发挥硬件并行能力。常用于需要极高性能的模块（如物理模拟、大规模AI）。
    
- **Unity的组件模式核心目标**：  
    **快速开发与灵活扩展**。通过可视化编辑和脚本组件快速构建对象逻辑，降低学习曲线，适合原型开发和中小规模项目。
    

---

### 类比说明

- **把ECS比作餐厅后厨**：  
    Chef（System）根据食材（Component）组合进行标准化处理。如果某订单（Entity）有"牛肉+洋葱"（Components），就按特定流程制作牛排。食材仅描述属性，处理逻辑完全由厨师决定。
    
- **把Unity组件模式比作智能手机**：  
    手机本体（GameObject）通过安装App（Component）扩展功能。虽然每个App独立存在，但用户通常认为"安装了微信的手机"就是一个能社交的设备，手机本身具有一定预设功能（如操作系统）。

## Update()与FixedUpdate()

### **核心概念**

- **FixedUpdate**：  
    被称为**逻辑帧**或**物理帧**，其调用间隔时间由`Time.fixedDeltaTime`（默认0.02秒）定义，**与设备帧率无关**。  
    Unity会通过**时间累积补偿机制**确保物理世界的确定性。即使设备卡顿，物理逻辑仍然按固定步长推进，避免因帧率波动导致的逻辑错误。
    
- **Time.fixedDeltaTime**：  
    是开发者预设的**固定时间间隔**（可配置），与实际硬件性能无关，恒等于预设值。即：  
    `逻辑时间推进量 = 调用次数 × Time.fixedDeltaTime`
    

---

- **FixedUpdate + Time.fixedDeltaTime = 确定性时基**：  
    是物理相关或要求时间严格一致性的逻辑（如网络同步状态,角色运动距离）的黄金组合。
- **Update + Time.deltaTime = 帧率依赖操作**：  
    适用于视觉效果、非物理交互行为。  
    正确区分二者是保障游戏体验稳定性的关键。
物理逻辑使用FixedUpdate,渲染使用Update

## Model、Obj与Info 

#### **1. Model：数据之源**

- **定义**：
    
    - 纯粹的静态数据容器，存储策划设计的数值和规则（如角色的基础血量、武器的攻击力、技能的基础效果）。
    - **不包含任何逻辑代码**，仅用于初始化Obj或提供计算依据。

#### **2. Obj：游戏中的实体**

- **定义**：
    
    - Unity中的`GameObject`及其附加组件，代表实际存在于游戏世界中的对象（如玩家、敌人、技能特效等）。
    - **由Model初始化**，并在运行时管理动态状态（如当前血量、技能冷却时间）。

#### **3. Info：逻辑的纽带**

- **定义**：
    
    - 传递系统间交互所需的临时参数（如添加Buff的层数、攻击事件的伤害值）。
    - **不直接关联Obj的生存周期**，类似“任务指令”或“事件参数”。
---

### **核心概念分层**

| **层级**    | **用途**        | **生命周期**     | **典型实现形式**                    | **例子**               |
| --------- | ------------- | ------------ | ----------------------------- | -------------------- |
| **Model** | **静态数据模板**    | 持久化（配置表、数据库） | 结构体（struct）、ScriptableObject  | 角色属性表、武器配置、技能基础效果    |
| **Obj**   | **动态游戏实体**    | 运行时（场景中存在）   | GameObject + MonoBehaviour 组件 | 玩家角色属性、敌人、子弹、技能特效    |
| **Info**  | **逻辑交互的中间数据** | 临时（逻辑流程中）    | 数据类（class）                    | Buff添加请求、伤害事件参数、生成指令 |

## DamageInfo  伤害流程

DamageInfo是贯穿整个伤害处理流程的，一个伤害处理流程通常是这样的：



![[Pasted image 20250211135512.png]]

**任何伤害都应该走DamageInfo**(包括额外攻击)

DamageInfo的具体属性：
- attacker: 攻击者的GameObject,可以为空,比如地图机关伤害,造成伤害的对象不是角色
- defender: 受到伤害者,不能为空
- tags：字符串数组，伤害类型的tag，比如是“直接伤害”、“间歇伤害”、“反弹伤害”等等
- **damage**：一个伤害数据结构，这是根据游戏不同来设计的，比如游戏中有金木水火土外加物理攻击，那么他就应该是有6个伤害数字组成的。我们通常忽略的一种情况是——策划会设计一些针对游戏中“元素属性”类似的东西有效的效果，比如“受到的火焰伤害减半”，如果此时受到的攻击是一个“暗影烈焰”，即暗属性伤害200点+火属性伤害200点，那么就得从这里面去找到暗影属性伤害减去一半；再比如“短时间内抑制所有受到的子弹伤害”，那么这个伤害的数据里面有一条肯定是子弹伤害，将子弹伤害设定为0，就抑制了。
- **damageDegree**：伤害的角度，也就是伤害打向defender的入射角度，通常这个角度来源是取子子弹的飞行方向或者aoe的中心点指向角色的位置的。这个角度配合角色当前的面向角度，就可以算出角色什么方向受到了伤害，假如需要做类似“背刺”的效果，那就得用上这个了。
- **criticalRate**：本次攻击的最终暴击率，大多游戏还是有暴击设计的，如果没有，可以砍掉这个数据。当一次伤害信息经历了所有流程之后，将最后的数值传递给策划编写的公式脚本，由策划来处理是否暴击了，以及暴击造成多少伤害。
- **hitRate**：和暴击率类似的概念，但是他俩在逻辑流程中实际上并无直接关系，即当有一个效果是“下一次攻击必定暴击”，这时候的DamageInfo哪怕hitRate是<=0的数字，也不妨碍criticalRate被设置为1或者更高的数字（假如策划认为1代表100%，这完全是由设计数值公式的策划来定义的），这两者并无依赖关系，不是说不命中就一定不能暴击，最后不命中能不能暴击，暴击了是不是一定命中，还是看策划写的公式脚本如何认为。
- **addBuffs**：这是一个“隐藏属性”，所以在上述结构中并没有标明，但是非常有必要说明一下。因为在整个伤害的流程中，我们可能因为一些角色身上的buff效果，他会需要添加新的buff效果，而这个新的buff效果并不想马上添加给角色（通常都是如此），比如说攻击者有一个buffA，他的效果是“攻击后目标受到割裂影响”，也就是在目标身上上一个buffB；还有一个优先级更低（更晚执行）的buffC，是“对割裂的目标造成的伤害提高200%”，策划设计的时候的想法是，这次攻击造成割裂，下次才是3倍伤害，但是因为执行顺序，产生了本次就直接上了割裂并且3倍伤害:

	- **即时添加Buff导致逻辑混乱**：  
	若Buff在事件处理过程中立即生效，后续步骤可能依赖于新增Buff的状态，如：
	
	```
	攻击触发 BuffA → 立即添加 BuffB（割裂） 
	同一攻击中 BuffC（若目标有割裂则增伤200%） → 检测到BuffB存在 → 错误触发
	```
	
	策划本意是本次触发割裂，**下次**攻击才享受增伤，但因执行顺序导致矛盾。
	#### **1. 分阶段处理**
	
	将Buff添加分为**请求收集阶段**和**实际应用阶段**：
	
	- **收集阶段**：在整个伤害计算期间，所有想要添加Buff的请求**暂存**到`DamageInfo.PendingBuffs`列表。
	- **应用阶段**：当完整的伤害流程（伤害计算、状态判断等）结束后，**批量处理**列表中的Buff请求。
	
	结果:
	▶ 本次攻击流程： 1. 触发BuffA → 申请添加BuffB（暂存列表） 2. 触发BuffC → 检测当前目标无BuffB → 增伤不生效 3. 最终伤害计算完成 4. 应用BuffB到目标 ▶ 下次攻击流程： 1. BuffC检测到目标已有BuffB → 增伤200%生效

## 角色(Character)

![[Pasted image 20250214110736.png]]

角色预制体看起来是"空"的,以前我做角色时大概率会给它直接绑定一个模型,然后放置这个模型的控制脚本,绑定属性等.把它当成一个固定的角色(主角或者小怪).但是这里的做法理念是无论是模型还是各种方面的控制,属性,buff,都是通过数据渲染.所以这里通过数据驱动此角色的构造.

CharacterObj包含下面组件:
![[Pasted image 20250214111607.png]]

### UnitBindManager

总之我们在“类似某个骨骼”的位置，加上一个UnitBindPoint的组件，他就会被UnitBindManager管理到。UnitBindManager要做的是，当我们需要角色在身上某个绑点播放特效的时候找到绑点去添加这个特效。

### UnitMove

也就是最终根据移动力来处理transform.poisition的赋值，其他一律不管。

### UnitAnim

是一个动画管理器，负责角色动画切换工作的，与技能动画无关.
	实现技能的动画是通过初始化PlaySightEffectOnCaster的key的Timeline把动画预制体放在UnitBindPoint下,持续时间duration结束后销毁.

### UnitRotate

他只负责接受GameObject.transform的Rotate请求.

### ChaState

ChaState 类是一个复杂的状态管理系统，负责处理角色的各种状态和行为。它通过与其他组件（如 UnitMove、UnitAnim、UnitRotate 等）的协作，实现了角色的移动、旋转、动画播放和技能释放等功能。
ChaState还有一个“side-effect”就是大半个buff管理器，负责角色身上的buff的增删改查。

### ChaPie

角色生命值和UI（脚下血条）同步

### PlayerController/SimpleAI

动态添加的对角色的“控制器”

### UnitRemover

指定时间之后移除掉所在的GameObject（Destroy(this.gameObject)）

## 时间轴（Timeline）

