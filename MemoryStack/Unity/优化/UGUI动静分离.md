#ugui  #优化 

	https://www.zhihu.com/question/472146091/answer/18572794558
	https://blog.csdn.net/weixin_43673589/article/details/121236786

### **1. Drawcall 的定义**

**Drawcall（绘制调用）​** 是 CPU 向 GPU 发送的渲染指令，告诉 GPU：“请绘制这个Mesh（网格）或Sprite（精灵）”。每个 Drawcall 对应一次独立的渲染操作，例如：

- 绘制一个按钮的Mesh
- 渲染一个文本的Sprite
- 绘制一个粒子效果

**关键特点**：

- ​**每个 Drawcall 都会触发一次 GPU 的渲染流程**，包括顶点着色器、片段着色器等计算。
- ​**Drawcall 数量直接影响性能**：Drawcall 越多，CPU 到 GPU 的通信开销越大，帧率可能下降（尤其是移动端）。

### **2. 为什么需要减少 Drawcall？**

- ​**性能瓶颈**：  
    GPU 的渲染速度远快于 CPU，因此 CPU 频繁发送 Drawcall 会成为瓶颈（想象成“快递员”（CPU）需要多次派送包裹到“仓库”（GPU），效率低）。
- ​**带宽压力**：  
    每个 Drawcall 需传输顶点数据、纹理坐标等信息，数据量越大，带宽占用越高。
- ​**实际案例**：
    - 一个场景有 1000 个按钮，每个按钮独立渲染，需要 1000 次 Drawcall。
    - 合批后，只需 1 次 Drawcall，性能显著提升。

### **3. Drawcall 合批技术的本质**

**合批（Batching）​** 的核心思想是将多个 Drawcall 合并为一个，减少 CPU 到 GPU 的通信次数。  
**实现方式**：

- ​**合并相同的材质（Material）​**：GPU Instancing 和静态合批依赖材质一致性。
- ​**合并相同的渲染状态**：如纹理、Shader、混合模式等。

### **4. 合批技术的分类**

#### ​**(1) 静态合批（Static Batching）​**

- ​**原理**：  
    在编辑器或初始化时，将多个相同材质的Mesh(相同sprite或者在同一个图集)合并成一个大的Mesh，生成一个顶点缓冲区（VertexBuffer）。
- ​**优点**：
    - 合批后的渲染效率极高，Drawcall 减少明显。
    - 适用于完全静态的UI元素（如背景、固定按钮）。
- ​**缺点**：
    - ​**内存占用高**：合并后的Mesh会占用更多显存。
    - ​**灵活性差**：一旦合批，修改单个元素的位置、颜色等属性需要重新计算整个Mesh。
- ​**典型应用**：
    - Unity UGUI 的Canvas预制体合批。
    - 场景中的静态模型（如建筑、树木）。

#### ​**(2) 动态合批（Dynamic Batching）​**

- ​**原理**：  
    在运行时动态将多个相同材质的小对象合并到一个Batch中，每帧重新计算顶点数据。
- ​**优点**：
    - 兼容动态变化的元素（如血条、UI动画）。
    - 不需要预处理，节省内存。
- ​**缺点**：
    - ​**CPU 开销大**：每帧需遍历对象并合并数据，可能导致性能下降。
    - ​**合并条件严格**：需保证材质、Shader、纹理一致。
- ​**典型应用**：
    - Cocos Creator 的UI合批。
    - 动态生成的粒子效果。

#### ​**(3) GPU Instancing（GPU 实例化）​**

- ​**原理**：  
    将大量相同模型的实例数据（如位置、旋转）存储在GPU内存中，通过一个Drawcall渲染所有实例。
- ​**优点**：
    - 极高效，适合渲染大量重复对象（如草地、NPC）。
    - 减少CPU到GPU的数据传输。
- ​**缺点**：
    - ​**不支持复杂动态逻辑**：实例参数（如位置）需在GPU端通过Shader读取，无法处理逐像素逻辑（如半透明叠加）。
    - ​**兼容性问题**：旧设备或某些API（如OpenGL ES）可能不支持。
- ​**典型应用**：
    - 地形植被、建筑群。
    - 3D场景中的重复模型（如货架、树木）。

### 5. Unity UGUI 使用的合批技术**

[Drawcall合批技术](https://zhida.zhihu.com/search?content_id=696829732&content_type=Answer&match_order=1&q=Drawcall%E5%90%88%E6%89%B9%E6%8A%80%E6%9C%AF&zhida_source=entity)，我们一般是有动态合批，静态合批，GPU Instancing合批。对于GUI部分，游戏引擎合批一般采用哪些技术呢？这个取决于游戏引擎的实现，比如Unity UGUI采用的是静态合批，预先把Mesh等合并好，而[Cocos Creator](https://zhida.zhihu.com/search?content_id=696829732&content_type=Answer&match_order=1&q=Cocos+Creator&zhida_source=entity) 引擎采用的是通用的动态合批。为什么不使用GPU Instancing合批呢？主要可能考虑有几个原因：半透明,九宫格，tiledmap等相关的处理，这类GPU Instancing不适合处理。不是所有的设备与显卡支持GPU Instancing, 兼容性不如动态合批or静态合批。所以大部分游戏引擎的UI，要么采用静态合批，要么采用动态合批。”静态合批与动态合批”都会导致一个问题,就是要重新计算与合并Mesh。”静态合批”合批的一个好处就是合并完后如果内部的UI元素没有位置等信息没有修改，就不用重新计算，渲染的时候直接把合并好的数据提交渲染就可以了。”动态合批”是遍历每个可以合批的UI元素，将数据合并后一起提交给GPU渲染。动态合批更灵活，更通用。

### 6. Unity UGUI 合批的开销分析

UGUI 是基于Canvas来进行合并计算的。这样会导致以下几个问题:

1. 不同Cavans下的UI无法合批
2. 每次合并的时候,会计算当前Canvas下的所有UI,具体流程为:
	1. 一开始计算合并Canvas下所有元素
	2. 每帧提交合并之后的结果给GPU渲染
	3. 某个UI发生改变时,先计算改变后的数据,在和其他不变的UI重新合并
3. 每次UI位置等信息变化,都会引发合并计算(2)
4. “不动物体”的合并计算开销是最小的，如果Cavans下所有的UI元素一旦创建都不再改变，那么合并计算这块只要计算一次,性能最好。
5. 当Cavans下有不断变化的物体时，每次都会有合并计算，此时不动的物体少，那么最后合并的时候物体的数据就少。

由上面的分析，很多人就得到一个结论: 动静分离，将不变的物体放一个canvas,变化的物体放一个canvas下，优化合并时候的开销。进而有人推导出来: “每个界面一个Cavans。然后面试时,被奉为经典，导致大家回答每个界面我们都做一个Canvas。减少Mesh合并的开销。”

**每个UI界面都做Canvas到底有没有必要?**

假设有两个界面，界面A(50个UI元素)，界面B(50个UI元素), 他们可以合批。假设界面A中的所有UI元素都不变化，界面B中的每个UI元素的位置在不断的改变，我们来分别讨论以下，界面A，界面B共用一个Canvas与界面A，界面B分开两个Cavans在合并上的开销。

情况1: 界面A，界面B共用一个Cavans;

Step1: 计算界面A中每个UI节点元素转换后的位置等信息, 计算A50个元素,计算一次;

Step2: 计算界面B中每个UI节点元素转换后的位置等信息，计算B50个元素，由于变化,每次都计算

Step3: 将A的50个元素信息(只计算一次) + B的50个元素信息，合并成100大的mesh，一起提交;

情况2； 界面A，界面B共用2个Cavavns;

![[Pasted image 20250320113330.png]]
仔细比对，我们发现，情况1比情况2好的点是，A,B可以一起提交，节约drawcall。情况2比情况1好的点是最后合并的时候，不用copy A的50个元素信息的数据，其它合并计算并没有太大的差别。

情况1比情况2能节约一个drawcall, 情况2比情况1在合并的时候，少copy 50个数据。

经上面分析,基于多Canvas的”动静分离”会打乱合批,能节省的是”合并时不变的元素的数据copy”。

总结: 没有必要每个UI界面都做一个Cavans, 一般我们做开发的时候，常规的游戏UI界面做一个Cavans, 大规模的弹出式滚动列表可以考虑做一个Cavans。游戏元素，如2D游戏中角色，2D/3D游戏中的玩家昵称，角色血条等，可以做一个Cavans。一般项目中2~3个Cavans就可以了。还是要把重点放在drawcall优化上。

**参考回答: 说说UGUI的动静分离是怎么一回事？**

Unity UGUI 会基于Canvas,将能合并的UI元素，计算合并到一起,然后再提交给GPU渲染来节约Drawcall,在这个过程中，如果某个UI元素改变了，就会引发一次合并计算。

”动静分离”一般指的是把那些不经常动的UI与经常动的2D元素分成不同的Cavans，来减少合并时候的开销。这个通常叫做”动静分离”。

我们在开发项目的时候，会把经常变化的游戏元素(2D游戏角色，玩家昵称，玩家血条等)做到一个Cavans下。把通常的游戏操作UI界面做一个Cavans下，对于那些UI内容非常多的如”任务滚动列表”等，我们也会考虑单独做一个Cavans,然后持续监测UI性能即可。

  
### Tips:Unity UI添加Canvas后无法点击

这是因为作为一个画布，必须有一个组件才能交互 ：Graphic Raycaster

Graphic Raycaster 是图形射线检测组件，用于检测投向Canvas的射线。

有了这个组件，画布上的UI才能被射线所检测到。

![[Pasted image 20250320114210.png]]

### Unity  Profiler ui分析

动静分离前:

![[Pasted image 20250320135659.png]]

动静分离后:

![[Pasted image 20250320114333.png]]
##### **1. Self Batch Count**

- ​**定义**：指单个 ​**Batch** 中能包含的 ​**最大对象数量**，由渲染管线自身的合批策略决定。
##### **2. Cumulative Batch Count**

- ​**定义**：指整个场景中 ​**实际生成的Batch总数**(**Drawcall的数量**)，包括静态合批（Static Batching）、动态合批（Dynamic Batching）和GPU Instancing等技术的结果。
- ​**作用**：直接反映渲染性能的“总负担”，是优化目标的核心指标。

在图中可以看到,在性能最差的页面中,使用动静分离之后,Batch总数并没有发生变化,而一次batch中最大对象数量,大幅下降,大幅减少了合并计算.